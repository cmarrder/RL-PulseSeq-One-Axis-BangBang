#pragma once

#include <complex>
#include <Eigen/Dense>
#include <Eigen/Eigenvalues>
#include <cmath>
#include <unsupported/Eigen/MatrixFunctions>
#include <unsupported/Eigen/FFT>
#include "Action.hpp"
#include "Sequence.hpp"
#include "Param.hpp"
#include "GaussQuad.hpp"
#include <gsl/gsl_sf_expint.h> // Package for Si and Ci, the sin and cos integrals.

/*
Choose from the following noise options:

  fermi_dirac
  1_over_f_with_low_cutoff
  lorentzian
  lorentzians
  gaussians

 */
std::string noise = "1_over_f_with_low_cutoff";
constexpr bool useFFT = false;
constexpr double cutoffEps = 1e-6;

constexpr std::complex<double> I(0.0, 1.0);

using namespace Eigen;

typedef Matrix<double, nPulse, 1> Feature;

ArrayXd myReciprocal(const ArrayXd& x, const double epsilon)
{
  // Can't just name this function reciprocal because there is a function named reciprocal in Torch library.
  // Calculate reciprocal of x. If |x| < epsilon, then return epsilon.
  ArrayXd zeroRemoved = (abs(x) < epsilon).select(ArrayXd::Constant(x.size(), epsilon), x);
  return 1.0 / zeroRemoved;
}

ArrayXd heaviside(const ArrayXd& x)
{
  // Heaviside step function as a function of x.
  return (x < 0).select(ArrayXd::Zero(x.size()), ArrayXd::Ones(x.size()));
}
  
ArrayXd boxcar(const ArrayXd& x, const double center, const double width)
{
  // Boxcar function as a function of x.
  double left = center - width / 2.0;
  double right = center + width / 2.0;
  return heaviside(x - left) - heaviside(x - right);
}

ArrayXd sinc(const ArrayXd& x)
{
  double EPS = 1e-20;
  ArrayXd res;
  res = sin(x * M_PI) * myReciprocal(x * M_PI, EPS);
  return res;
}

double sinc(const double x)
{
  double EPS = 1e-20;
  double y = 0.0;
  if (x == 0.0)
  {
    y = M_PI * EPS; 
  }
  else
  {
    y = M_PI * x;
  }
  return std::sin(y) / y;
}

ArrayXd lorentzian(const ArrayXd& x, const double center, const double fwhm)
{
  // Normalized Lorentzian as a function of x.
  int nA = x.size();
  ArrayXd numerator = ArrayXd::Ones(nA) * fwhm / 2 / M_PI;
  ArrayXd denominator = (x - center).pow(2) + std::pow(fwhm / 2, 2);
  return numerator / denominator;
}

ArrayXd lorentzians(const ArrayXd& x, const ArrayXd& centers, const ArrayXd& fwhms, const ArrayXd& heights)
{
  // Sum of Lorentzians. Each of which is normalized.
  // NOTE: centers and fwhms must have same length
  int nCenter = centers.size();
  int nA = x.size();
  ArrayXd sum = ArrayXd::Zero(nA);
  for (int k = 0; k < nCenter; k++)
  {
    sum += heights(k) * M_PI * (fwhms(k) / 2) * lorentzian(x, centers(k), fwhms(k));
  }
  return sum;
}

ArrayXd gaussian(const ArrayXd& x, const double mu, const double sigma, const double amplitude)
{
  // Normalized Gaussian as a function of x.
  ArrayXd numerator = exp(-square((x - mu) / sigma) / 2);
  double denominator = sigma * std::sqrt(2 * M_PI); 
  return amplitude * numerator / denominator;
}

ArrayXd gaussians(const ArrayXd& x, const ArrayXd& mus, const ArrayXd& sigmas, const ArrayXd& heights)
{
  // Sum of Gaussians. Each of which is normalized.
  // NOTE: centers and fwhms must have same length
  // HOW NORMALIZE???
  int nCenter = mus.size();
  int nA = x.size();
  ArrayXd sum = ArrayXd::Zero(nA);
  for (int k = 0; k < nCenter; k++)
  {
    sum +=  gaussian(x, mus(k), sigmas(k), heights(k));
  }
  return sum;
}

double x_Si(const double x)
{
  return x * gsl_sf_Si(x);
}

double xSq_Ci(const double x)
{
  if (x == 0.0)
  {
    return 0.0;
  }
  else
  {
    return x * x * gsl_sf_Ci(x);
  }
}

class Crystal {

  Sequence sequence;
  ArrayXd freq;
  ArrayXd weights;
  ArrayXd sOmega;
  ArrayXd weightedSOmega;
  ArrayXd actionHarmonics;
  ArrayXd actionEtas;
  double dFreq;
  double dTime;
  int idxMaxFreq;
  int nFreq;
  int cutoffIdx;
  int nTimePts;
  double noiseParam1;
  double noiseParam2;
  double eta1;
  double initialChi;
  double initialAvgInfid;
  ArrayXcd FT_of_ft_term1;
  ArrayXcd FT_of_ft_prefactor;
  ArrayXd FT_of_ft_2_times_signs;
  
  ArrayXd initialCenterTimes()
  {
    // Wrapper function used to choose the initial pulse center times.
    //return CPMGCenterTimes();
    return PDDCenterTimes();
    //VectorXd centerTimes(5);
    //centerTimes << 0, 0.25, 0.25, 0.25, 0.75;
    //return centerTimes;
  }
  
  ArrayXd peakLocCPMG() const
  {
    // Calculate the peaks of the CPMG filter function 
    int nPeaks = nPulse; // Currently only use nPulse many peaks. Can add more if need be.
    ArrayXd range = ArrayXd::LinSpaced(nPeaks, 0, nPeaks - 1); // range of integers from 0 to nPeaks - 1
    double denom = maxTime / nPulse;
    ArrayXd centers = (range.array() + 0.5) / denom;
    return centers;
  }

  ArrayXd fermiDiracDistrib(ArrayXd frequencies, double chemPot, double temperature)
  {
    ArrayXd y = ArrayXd::Zero(frequencies.size());
    ArrayXd x = (frequencies - chemPot) / temperature; 
    y = inverse((exp(x) + 1));
    return y;
  }

  ArrayXd computeSOmega(ArrayXd frequencies)
  {
    ArrayXd somega = ArrayXd::Zero(nFreq);
    
    if (noise == "fermi_dirac")
    {
      somega = fermiDiracDistrib(frequencies, noiseParam1, noiseParam2);
    }
             
    else if (noise == "1_over_f_with_low_cutoff")
    {
      // Set the frequencies below cutoffFreq to 1
      double S0 = 1.0;//noiseParam1;
      double cutoffFreq = 1.0 / maxTime;
      ArrayXd lowFreqRemoved = (abs(frequencies) < cutoffFreq).select(ArrayXd::Constant(frequencies.size(), 1.0), frequencies);
      somega = S0 / lowFreqRemoved;
    }

    else if (noise == "lorentzian")
    {
      double flipRate = (1.0 / 10.0) * (1.0 / maxTime);
      double fwhm = 4 * flipRate;
      //// Divide output by number of elements in centers to normalize.
      somega = lorentzian(freq, 0, fwhm);
    }

    else if (noise == "lorentzians")
    {
      double cpmgPeakFreq = nPulse / (2 * maxTime); // The first peak frequency of the CPMG filter function
      Array2d centers(0.0, 0.7 * cpmgPeakFreq); // Place Lorentzian at origin and some fraction of location of peak of CPMG Filter function
      int nPeaks = centers.size(); 
      Array2d fwhms(1.0 / 2.0, 1.0 / 4.0); // MAKE SURE FWHM IS NOT SMALLER THAN KEY FREQUENCIES IN TIME MESH
      ArrayXd heights = inverse(2 * M_PI * fwhms); 
      //// Divide output by number of elements in centers to normalize.
      somega = lorentzians(frequencies, centers, fwhms, heights) / nPeaks;
    }

    else if (noise == "gaussians")
    {
      ArrayXd centers = peakLocCPMG(); // Place Gaussian at each peak of CPMG Filter function
      centers = centers + centers(0) / 2; // Shift so that noise peaks are in between CPMG filter function peaks
      int nPeaks = centers.size(); 
      ArrayXd sigmas = ArrayXd::Ones(nPeaks) / 2;
      ArrayXd heights = centers.pow(-2);
      somega = gaussians(frequencies, centers, sigmas, heights);
    }
   
    return somega; 
  }

  ArrayXcd computeFOmega() const
  {
    // Compute Fourier transform of the switching function f(t).
    if (useFFT == true)
    {
        ArrayXd ctrlSig = computeCtrlSig();
        ArrayXd ctrlSigPadded = ArrayXd::Zero(nTimePts);
        ctrlSigPadded.head(nTimeStep) = ctrlSig;
        
        VectorXcd FT_of_ft = VectorXcd::Zero(nTimePts);
        FFT<double> fft;
        fft.fwd(FT_of_ft, ctrlSigPadded.matrix());
        return dTime * FT_of_ft(seq(0, idxMaxFreq)).array(); // Only consider the positive freqs. Normalize by multiplying by dTime.
    }
    else
    {
        ArrayXd timeWithEnds = ArrayXd::Zero(nPulse + 2);
        timeWithEnds(0) = 0;
        timeWithEnds(nPulse + 1) = maxTime;
        timeWithEnds(seq(1, nPulse)) = sequence.getCenterTimes();
        
        ArrayXd boxcarWidths = timeWithEnds(seq(1, nPulse+1)) - timeWithEnds(seq(0, nPulse));
        ArrayXd boxcarCenters = (timeWithEnds(seq(1, nPulse+1)) + timeWithEnds(seq(0, nPulse))) / 2;

	//std::cout << std::endl << "freq" << std::endl << freq << std::endl;
        
        ArrayXcd FT_of_ft = ArrayXcd::Zero(nFreq);
        for (int k = 0; k < nPulse + 1; k++) {
                ArrayXd boxFT = sinc(freq * boxcarWidths(k));
	        //std::cout << std::endl << "boxFT" << std::endl << boxFT << std::endl;
                //std::cout << std::endl << exp(-I * 2.0 * M_PI * freq * boxcarCenters(k)) << std::endl;
                FT_of_ft = FT_of_ft + std::pow(-1, k) * exp(-I * 2.0 * M_PI * freq * boxcarCenters(k)) * boxcarWidths(k) * boxFT;
        }
	//std::cout << std::endl << "Times" << std::endl << timeWithEnds << std::endl;
	//std::cout << std::endl << "Ftilde" << std::endl << FT_of_ft << std::endl;
        return FT_of_ft;
    }
  }

  ArrayXd computeFOmegaAbs2() const
  {
    ArrayXcd FT_of_ft = computeFOmega();
    return FT_of_ft.cwiseAbs2();
  }

  ArrayXd computeCtrlSig() const
  {
    /*
    Schematic to illustrate the binning with nTime=3 for simplicity:
    time points: t0          t1          t2          t3
    bins:        [    b0      )
                              [    b1     )
			                  [    b2     ]
    Here, bracket [ signifies inclusive bound, parentheses ( signifies exclusive bound.
    */

    // Compute control signal f(t) using the pulse sequence.
    ArrayXd controlSignal = ArrayXd::Ones(nTimeStep);
    ArrayXd pulseCenters = sequence.getCenterTimes();
    double binWidth = maxTime / (nTimeStep);


    ///////////////////////////////////
    /// NEW VERSION:

    //ArrayXi binIdxs = (floor(pulseCenters.array() / binWidth)).cast<int>();
    //// If an element of binIdxs is equal to nTimeStep, make it nTimeStep-1.
    //binIdxs = (binIdxs.array() == nTimeStep).select(ArrayXi::Constant(nPulse, nTimeStep-1), binIdxs);
    //
    //int maxBinIdx = nTimeStep - 1;
    //for (int k = 0; k < nPulse; k++)
    //{
    //  int b = binIdxs(k);
    //  controlSignal(seq(b, maxBinIdx)) = -controlSignal(seq(b, maxBinIdx));
    //}
    /////////////////////////////////

    //// OLD VERSION:
    ArrayXi binIdxs = (floor(pulseCenters.array() / binWidth)).cast<int>();
    // If an element of binIdxs is equal to nTimeStep, make it nTimeStep-1.
    binIdxs = (binIdxs == nTimeStep).select(ArrayXi::Constant(nPulse, nTimeStep-1), binIdxs);
    ArrayXi binCounts = ArrayXi::Zero(nTimeStep);
    double sign = 1.0;
    
    for (int k = 0; k < nPulse; k++)
    {
      binCounts(binIdxs(k)) += 1;
    }
    for (int i = 0; i < nTimeStep; i++)
    {
      if (binCounts(i) % 2 == 1)
      {
        sign = -sign;
      }
      controlSignal(i) = sign;
    }
    
    return controlSignal;
  }

  int getCutoffIndex(ArrayXd somega, ArrayXd frequencies)
  {
    if (somega.size() != frequencies.size())
    {
      std::cout << "In getCutoffIndex, somega and frequencies of different sizes." << std::endl;
    }
    int numF = frequencies.size();
    for (int k = numF - 1; k > -1; k--)
    {
      // Based on upper bounds on filter, do we need factor of nPulse in numerator of following expression?
      if (somega(k) / std::pow(frequencies(k), 2) > cutoffEps)
      {
        return k;
      }
    }
    return numF - 1;
  }

  double getCutoffFrequency(double initialGuess)
  {
    // Determine UV Cutoff
    Array2d S_div_freq_sq;
    Array2d freqTestPts;

    double freqIncrement = initialGuess / 100.0;
    double freqMax = initialGuess + freqIncrement;

    // Initialize
    freqTestPts << initialGuess, freqMax;
    S_div_freq_sq = computeSOmega(freqTestPts) / pow(freqTestPts, 2.0);

    while (S_div_freq_sq(1) / S_div_freq_sq(0) > 1e-9)
    {
      freqMax = freqMax + freqIncrement;
      freqTestPts(1) = freqMax;
      S_div_freq_sq = computeSOmega(freqTestPts) / pow(freqTestPts, 2.0);
    }
    return freqMax;
  }


  void initializeTimeFreqData()
  {
    dTime = maxTime / nTimeStep; // Global variable
    if (useFFT == true)
    {
      nTimePts = (nTimeStep + 1) + nZero; // Global variable
      idxMaxFreq = (nTimePts - 1 - (nTimePts - 1) % 2) / 2; // Global variable. Index of max positive frequency in fft freq mesh.
      ArrayXd range = ArrayXd::LinSpaced(idxMaxFreq + 1, 0, idxMaxFreq); // range of integers from 0 to idxMaxFreq
      
      freq = range / (nTimePts * dTime); // Global variable
      nFreq = freq.size(); // Global variable
      dFreq = freq(1) - freq(0); // Global variable
    } 
    else
    {
      double UV_Cutoff_Guess = 0;
      if (noise == "fermi_dirac")
      {
        UV_Cutoff_Guess = noiseParam1;
      }
               
      else if (noise == "1_over_f_with_low_cutoff")
      {
        double cutoffFreq = 1.0 / maxTime;
        UV_Cutoff_Guess = cutoffFreq;
      }

      else if (noise == "lorentzian")
      {
        double flipRate = (1.0 / 10.0) * (1.0 / maxTime);
        double fwhm = 4 * flipRate;
        UV_Cutoff_Guess = fwhm / 2.0;
      }

      else if (noise == "lorentzians")
      {
        double cpmgPeakFreq = nPulse / (2 * maxTime); // The first peak frequency of the CPMG filter function
        Array2d centers(0.0, 0.7 * cpmgPeakFreq); // Place Lorentzian at origin and some fraction of location of peak of CPMG Filter function
        Array2d fwhms(1.0 / 2.0, 1.0 / 4.0); // MAKE SURE FWHM IS NOT SMALLER THAN KEY FREQUENCIES IN TIME MESH
        Array2d heights = inverse(2 * M_PI * fwhms); 
        UV_Cutoff_Guess = centers(1) + fwhms(1) / 2.0;
      }

      else if (noise == "gaussians")
      {
        ArrayXd centers = peakLocCPMG(); // Place Gaussian at each peak of CPMG Filter function
        centers = centers + centers(0) / 2; // Shift so that noise peaks are in between CPMG filter function peaks
        int nPeaks = centers.size(); 
        ArrayXd sigmas = ArrayXd::Ones(nPeaks) / 2;
        ArrayXd heights = centers.pow(-2);
        UV_Cutoff_Guess = centers(nPeaks - 1) + sigmas(nPeaks - 1);
      }

      nFreq = 2000; // Global variable. Should be factor of 5.
      double maxFreq = 0;
      maxFreq = getCutoffFrequency(UV_Cutoff_Guess);
      std::cout << "maxFreq" << std::endl << maxFreq << std::endl;
       
      // Check is FID filter is normalized, then shift window as long as S / freq**2 from UV below a cutoff, or as long as chi remains the same after freq doubling

      // Gaussian quadrature points and weights
      ArrayXXd gQuad = shiftedGaussQuad5(0, maxFreq, nFreq/5);
  
      freq = gQuad.col(0);
      weights = gQuad.col(1);

    }
  }


  void writeInitial(std::string& dir)
  {
    std::ofstream out_freq(dir + "/freq.txt");
    out_freq << freq << std::endl;
    out_freq.close();

    std::ofstream out_weights(dir + "/weights.txt");
    out_weights << weights << std::endl;
    out_weights.close();

    std::ofstream out_sOmega(dir + "/sOmega.txt");
    out_sOmega << sOmega << std::endl;
    out_sOmega.close();

    std::ofstream out_noiseParam1(dir + "/noiseParam1.txt");
    out_noiseParam1 << noiseParam1 << std::endl;
    out_noiseParam1.close();

    std::ofstream out_noiseParam2(dir + "/noiseParam2.txt");
    out_noiseParam2 << noiseParam2 << std::endl;
    out_noiseParam2.close(); 
    
    std::ofstream out_eta1(dir + "/eta1.txt");
    out_eta1 << eta1 << std::endl;
    out_eta1.close(); 

    std::ofstream out_harmonics(dir + "/harmonics.txt");
    out_harmonics << actionHarmonics << std::endl;
    out_harmonics.close(); 

    std::ofstream out_maxTime(dir + "/maxTime.txt");
    out_maxTime << maxTime << std::endl;
    out_maxTime.close();

    std::ofstream out_nTimeStep(dir + "/nTimeStep.txt");
    out_nTimeStep << nTimeStep << std::endl;
    out_nTimeStep.close();

    std::ofstream out_nPulse(dir + "/nPulse.txt");
    out_nPulse << nPulse << std::endl;
    out_nPulse.close();

    std::ofstream out_initialState(dir + "/initialState.txt");
    out_initialState << initialCenterTimes() << std::endl;
    out_initialState.close();

    std::ofstream out_initialFilter(dir + "/initialFilter.txt");
    out_initialFilter << computeFOmegaAbs2() << std::endl;
    out_initialFilter.close();

    std::ofstream out_initialSignal(dir + "/initialSignal.txt");
    out_initialSignal << computeCtrlSig() << std::endl;
    out_initialSignal.close();
  }

  public:

  Crystal() {};

  Crystal(Param& param)
  {
    noiseParam1 = param.noiseParam1;
    noiseParam2 = param.noiseParam2;
    //etaN = param.etaN; // The eta associated with the highest harmonic action, that whose harmonic number = nPulse.
    eta1 = param.eta1; // The eta associated with j=1.

    // Initialize harmonics for action functions. We need to do this in a roundabout way because
    // C++ doesn't allow comma initialization of Eigen::ArrayXd instances when in a class but outside of a method.
    ArrayXd harmonics(8);
    double J = static_cast<double>(nPulse+2);
    harmonics << 1, -1, 2, -2, J-1, -(J-1), J, -J;
    actionHarmonics = harmonics;
    //actionEtas = (nPulse / actionHarmonics.array()).abs() * etaN; 
    actionEtas = (1 / actionHarmonics.array()).abs() * eta1; 

    std::cout << "actionHarmonics:" << std::endl << actionHarmonics.transpose() <<std::endl;
    std::cout << "actionEtas:" << std::endl << actionEtas.transpose() <<std::endl;
   
    initializeTimeFreqData(); 
    sOmega = computeSOmega(freq);
    weightedSOmega = sOmega * weights;

    if (useFFT == true)
    {
      cutoffIdx = getCutoffIndex(sOmega, freq);
    }

    sequence.updateCenterTimes(initialCenterTimes());

    writeInitial(param.oDir);

    std::cout << "Initial fid: " << avgFid() << std::endl;

  }

  void reset()
  {
    sequence.updateCenterTimes(initialCenterTimes());
  }

  void step(int action)
  {
    ArrayXd oldTimes = sequence.getCenterTimes();
    ArrayXd newTimes = kappa(oldTimes, actionHarmonics[action], actionEtas[action]);
    sequence.updateCenterTimes(newTimes);
  }

  Feature feature() const
  {
    Feature feature;
    // Extract pulse center times from sequence. 
    feature = (sequence.getCenterTimes()).matrix();
    return feature;
  }

  double chi_1_over_f_low_cutoff(double S0, double freqCutoff) const
  {
    ArrayXd timeWithEnds = ArrayXd::Zero(nPulse + 2);
    timeWithEnds(0) = 0;
    timeWithEnds(nPulse + 1) = maxTime;
    timeWithEnds(seq(1, nPulse)) = sequence.getCenterTimes();
    double angfreqCutoff = 2 * M_PI * freqCutoff;

    double sum1 = 0.0;
    double sum2 = 0.0;
    double sum3 = 0.0;
    double sum4 = 0.0;

    for (int n = 0; n < nPulse + 1; n++)
    {
      double an = timeWithEnds(n+1) - timeWithEnds(n);
      double phase = angfreqCutoff * an;
      sum1 += (x_Si(phase) + std::cos(phase) - 1) / angfreqCutoff;
      sum3 += an * an * (-gsl_sf_Ci(phase) + 0.5 * std::pow(sinc(an * freqCutoff), 2) + sinc(2 * an * freqCutoff));
    }

    for (int i = 0; i < nPulse; i++)
    {
      for (int j = i+1; j < nPulse + 2; j++)
      {
        double sign = std::pow(-1.0, i+j);
	// Define time differences for the calculation
        double phi1 = angfreqCutoff * (timeWithEnds(j) - timeWithEnds(i+1));
        double phi2 = angfreqCutoff * (timeWithEnds(j) - timeWithEnds(i));
        double phi3 = angfreqCutoff * (timeWithEnds(j) - timeWithEnds(i));
        double phi4 = angfreqCutoff * (timeWithEnds(j+1) - timeWithEnds(i+1));

        sum2 += sign *
                (x_Si(phi1) + x_Si(phi2)
                - x_Si(phi3) - x_Si(phi4)
                + std::cos(phi1) + std::cos(phi2) - std::cos(phi3) - std::cos(phi4));
        sum4 += sign *
                ( - xSq_Ci(phi1) - xSq_Ci(phi2)
                + xSq_Ci(phi3) + xSq_Ci(phi4)
                + phi1 * std::sin(phi1) + phi2 * std::sin(phi2)
                - phi3 * std::sin(phi3) - phi4 * std::sin(phi4)
                - std::cos(phi1) - std::cos(phi2) + std::cos(phi3) + std::cos(phi4));
	return S0 * ((sum1 + sum2 / angfreqCutoff) / M_PI + sum3 + sum4 / angfreqCutoff / angfreqCutoff);
	
      }
    }
    
    return 0.0;
  }
  
  double chi() const
  {
    double overlap;
    if (useFFT == true)
    {
      ArrayXd fOmegaAbs2 = computeFOmegaAbs2();
      overlap =  (fOmegaAbs2.head(cutoffIdx).transpose() * sOmega.head(cutoffIdx)).sum() * dFreq; // Select 0 element because technically result of vector product is vector of length 1
    }
    else if (noise == "1_over_f_with_low_cutoff")
    {
      double amplitude = 1;
      double cutoff = 1.0 / maxTime;
      overlap = chi_1_over_f_low_cutoff(amplitude, cutoff);

      // Testing:
      double overlap2 = 0;
      ArrayXd fOmegaAbs2 = computeFOmegaAbs2();
      overlap2 =  (fOmegaAbs2 * weightedSOmega).sum(); // Select 0 element because technically result of vector product is vector of length 1
      //std::cout << std::endl << "Exact chi:" << std::endl << overlap << std::endl;
      //std::cout << "Numerical chi:" << std::endl << overlap2 << std::endl;
      //std::cout << "Percent error:" << std::endl << (overlap - overlap2) / overlap << std::endl;


    }
    else
    {
      ArrayXd fOmegaAbs2 = computeFOmegaAbs2();
      overlap =  (fOmegaAbs2 * weightedSOmega).sum(); // Select 0 element because technically result of vector product is vector of length 1
    }
    return overlap;
  }

  double getInitialChi() const
  {
    return initialChi;
  }

  double avgFid() const
  {
    // Calculate average fidelity.
    return 0.5 * (1 + std::exp(-chi()));
  }

  double avgInfid() const
  {
    // Calculate average infidelity.
    return 1.0 - 0.5 * (1 + std::exp(-chi()));
  }

 double relativeAvgInfid() const
 {
   return avgInfid() / initialAvgInfid;
 } 

 ArrayXd getSum() const
  {
    ArrayXd fOmegaAbs2 = computeFOmegaAbs2();
    //double overlap =  (fOmegaAbs2.head(cutoffIdx + 1).transpose() * sOmega.head(cutoffIdx + 1))(0) * dFreq; // Select 0 element because technically result of vector product is vector of length 1
    
    return fOmegaAbs2 * sOmega;
  }

 ArrayXd getFilter() const
 {
	 return computeFOmegaAbs2();
 }

};
